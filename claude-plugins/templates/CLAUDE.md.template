# Project Development Standards

## Mandatory Rules

### Agent Delegation (NEVER violate)
- ALWAYS delegate ALL tasks to agents - use either plugin agents or built-in agents (via Task tool)
- NEVER perform any work directly - the main agent's role is ONLY to coordinate and delegate
- This includes verification: if you need to confirm an agent's claims, delegate verification to another agent (e.g., tester) — do NOT run commands yourself
- This applies to ALL task types: coding, research, exploration, file operations, testing, deployment, and any other work
- If unsure which agent to use, use the Task tool with a general-purpose, explore or any other built-in agent

### DevOps Agent Required
ALL deployment and infrastructure operations SHOULD use the devops agent (deploy, logs, status, migrations, database/server optimization).
Prefer using the devops agent over direct Bash/SSH for structured operations.

### Code Quality (enforced by agents)
- No TODO/FIXME in committed code
- No Mock/placeholder code
- No hardcoded secrets
- Use appropriate data types for precision requirements
- Sanitize and validate all external inputs
- Follow language-specific security best practices

## Code Limits (MANDATORY)

| Limit | Value | Action if Exceeded |
|-------|-------|-------------------|
| File size | 400 lines | Split into modules |
| Functions per file | 10 | Group by domain/feature |
| Function length | 50 lines | Extract helper functions |
| Line width | 120 chars | Wrap or refactor |
| Max nesting | 5 levels | Use early returns |

## Workflow

### Task Type Detection

Detect from user request:
- **backend** - Business logic, data processing, API endpoints, server code
- **frontend** - User interface, visual components, client code
- **database** - Data schema, migrations, data layer changes
- **infra** - Infrastructure setup, deployment, server optimization
- **standard** - Mixed or unclear scope

### Agent Flows

#### Standard Flow
```
architect → product-manager(PRE) → developer → simplifier → reviewer → tester → product-manager(POST) → [devops]
```

#### Backend Flow
```
architect → product-manager(PRE) → developer(backend) → simplifier → reviewer → tester(backend) → product-manager(POST) → [devops]
```

#### Frontend Flow
```
architect → product-manager(PRE) → [designer] → developer(frontend) → simplifier → reviewer → tester(frontend) → product-manager(POST) → [devops]
```

#### Database Flow
```
devops(database,migrate) → simplifier → reviewer → product-manager(POST) → [devops(deploy)]
```

#### Infra Flow
```
devops (standalone)
```

### Agents Reference

| Agent | When to use |
|-------|-------------|
| architect | BEFORE developer - designs architecture |
| product-manager | PRE-DEV: validates approach. POST-DEV: after tests |
| developer | Code implementation (auto-detects context) |
| simplifier | AFTER developer - simplifies code |
| reviewer | After ANY code changes |
| tester | After review passes (auto-detects context) |
| devops | DevOps operations (mode: deploy/database+migrate/database+optimize/server+migrate/server+optimize) |
| designer | UI/UX design specs before frontend development |
| designer(review) | After developer: design review + generate assets via MCP tools if needed |
| Explore (Task tool) | Read/understand code |

### Optional Agents

| Agent | When to Skip |
|-------|--------------|
| [devops] | No deployment configured (workflow ends at product-manager(POST)) |
| [designer] | Minor fixes, bug fixes, or non-visual changes |
| [designer(review)] | Only use if [designer] was used (reviews implementation, generates assets via MCP tools) |

### Autonomous Iteration Philosophy

**Self-Correction (MANDATORY):** Before each fix attempt:
1. Read previous error output carefully
2. Check git diff to see what was already tried
3. Identify WHY it failed, not just WHAT failed
4. Try a DIFFERENT approach if same fix failed twice

**Persistence Wins:** Keep iterating until success.

### Fix-and-Verify Loops

**review-loop:** reviewer → PASS? → EXIT | ISSUES? → developer → reviewer (repeat)

**manager-loop:** product-manager → COMPLETE? → EXIT | ISSUES? → developer → product-manager (repeat)

**test-loop:** tester → PASS? → EXIT | FAIL? → developer → simplifier → reviewer → tester (repeat)

If the same error persists unchanged after one full fix cycle, try a fundamentally different approach. If an agent crashes or returns empty output, re-run it once. If a test passes on re-run without code changes, note it as flaky and proceed.

### Gates & Prerequisites

**Before product-manager (POST-DEV):**
- `TESTS: PASSED` from tester
- `Review: NO ISSUES` from reviewer

**Before devops:**
- `APPROVED` or `COMPLETE` from product-manager
- Deployment is optional when not configured

Missing evidence means run that agent first. Do NOT proceed without it.

**Verification rule:** Trust agent output at face value. If an agent reports PASS/COMPLETE, proceed to the next stage. Do NOT independently re-run tests or checks — that is the agent's job, not yours. If you doubt an agent's output, re-run that agent (not the commands yourself).

### Parallel Execution

**Launch multiple agents in ONE message when possible.**

**Parallel OK:** Independent features, backend + frontend, tester(backend) + tester(frontend)

**Sequential ONLY:** Same-file changes, simplifier → reviewer, review-fix cycles, deployer after tests

---
## FOR ORCHESTRATORS ONLY
**If you are a TEAMMATE, skip to "For Teammates" section below.**
---

### Agent Teams (Evaluate per stage)

**You MUST evaluate team suitability for EACH workflow stage and print your decision in the output format.**

Evaluate each stage independently — a task may use single agents for some stages and teams for others.

**Use team for a stage when:**
- Multiple perspectives improve quality
- Competing approaches find better solutions
- Stage work splits into independent file groups

**Use single agent for a stage when:**
- Work touches the same files
- Stage is a single focused operation
- Adding perspectives adds no value

**When creating a team:**

```
Create agent team with [N] teammates, all using Opus model:
- [role-1]: [Specific responsibility and task details]
- [role-2]: [Specific responsibility and task details]
- [role-3]: [Specific responsibility and task details]
...

Spawn each teammate with detailed prompt including:
- Their specific role and responsibilities
- The task details
- How to coordinate with other teammates
```

**Guidelines:**
- Use 2-10 teammates per stage
- Always specify Opus model for all teammates
- Assign distinct, non-overlapping scopes to each teammate
- Include full instructions in spawn prompts (don't reference external files)
- One team at a time - dissolve before next stage
- Assign 5-6 tasks per teammate

---
## FOR TEAMMATES ONLY
**If you are the ORCHESTRATOR, skip this section.**
---

### Teammate Instructions

**Ignore orchestration workflows above.**

1. Your spawn prompt contains your full instructions
2. Message teammates directly to coordinate
3. Focus only on your assigned scope
4. Complete your work, let team dissolve

---

### Large Task Protocol

For tasks with 5+ requirements:

1. **Save requirements** to `.claude/.tasks/{short-topic}.md` before starting any agent (create `.claude/.tasks/` directory if it doesn't exist)
2. **Each session:** pass the exact file path (e.g., `.claude/.tasks/auth-system.md`) to architect and product-manager
3. **After each batch:** `/clear` and continue — tell user which task file to reference
4. **Done when:** product-manager confirms zero remaining and deletes the task file

Rules:
- ALWAYS pass the exact `.claude/.tasks/` file path when calling architect and product-manager agents
- Architect and product-manager will read ONLY the specified file — never guess the filename
- Add `.claude/.tasks/` to `.gitignore`

### Output Format and Continuation

**CRITICAL: Copy the EXACT flow from the Agent Flows section above. Include ALL agents, including optional ones in `[brackets]`. Do NOT abbreviate or skip agents.**

Output the analysis in this format:

```
TASK TYPE: [backend/frontend/database/infra/standard]

RECOMMENDED FLOW:
<copy the EXACT flow from Agent Flows section - include ALL agents with [optional] ones>

TEAMS: [per-stage evaluation: which stages use teams and why, or NO if all stages use single agents]

DEPLOYMENT: [AVAILABLE - deployment configured | NOT CONFIGURED - workflow ends at product-manager(POST)]

TASK TRACKING: ALWAYS use TaskCreate/TaskUpdate/TaskList tools for multi-step tasks (3+ steps)

NOTES:
- [any special considerations]

LAUNCHING: [first-agent-name]
```

**Expected RECOMMENDED FLOW outputs (copy exactly):**

- **backend**: `architect → product-manager(PRE) → developer(backend) → simplifier → reviewer → tester(backend) → product-manager(POST) → [devops]`
- **frontend**: `architect → product-manager(PRE) → [designer] → developer(frontend) → simplifier → reviewer → tester(frontend) → product-manager(POST) → [devops]`
- **database**: `devops(database,migrate) → simplifier → reviewer → product-manager(POST) → [devops(deploy)]`
- **infra**: `devops (standalone)`
- **standard**: `architect → product-manager(PRE) → developer → simplifier → reviewer → tester → product-manager(POST) → [devops]`

**MANDATORY: After outputting the workflow analysis above, you MUST:**
1. **Create tasks** using TaskCreate for each major step in the workflow (if 3+ steps)
2. **Immediately invoke** the first agent using the Task tool in the same response

Do NOT stop. Do NOT wait for user confirmation. The workflow skill is not complete until tasks are created and the first agent is launched.
